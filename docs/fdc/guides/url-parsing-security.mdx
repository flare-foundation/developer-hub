---
title: URL Parsing Security
slug: url-parsing-security
authors: [amadiaflare]
description: Secure URL validation patterns for FDC Web2Json attestations to prevent MitM attacks.
tags: [advanced, fdc, solidity]
keywords:
  [flare-data-connector, security, url-parsing, mitm-prevention, web2json]
sidebar_position: 10
---

import CodeBlock from "@theme/CodeBlock";
import PriceVerifierCustomFeed from "!!raw-loader!/examples/developer-hub-solidity/PriceVerifierCustomFeed.sol";

# URL Parsing Security for FDC

When using the `Web2Json` attestation type, your smart contract receives data along with a proof that includes the source URL.
Without proper URL validation, an attacker could submit a valid FDC proof from a malicious source and have your contract accept it as legitimate data.

This guide covers security patterns for parsing and validating URLs in your FDC-enabled smart contracts.

## The Problem: Man-in-the-Middle Attacks

FDC proves that data came from a specific URL.
It does **not** prove that the URL is the one you intended to use.

Consider a price feed contract that expects data from CoinGecko.
An attacker could:

1. Create a malicious API endpoint that returns manipulated prices
2. Get a valid FDC attestation for their malicious endpoint
3. Submit this proof to your contract
4. Your contract accepts the manipulated data because the FDC proof is cryptographically valid

URL validation ensures your contract only accepts data from trusted sources.

## Security Layers

A robust URL validation strategy includes multiple layers:

| Layer      | Purpose                                       | Example                         |
| ---------- | --------------------------------------------- | ------------------------------- |
| Protocol   | Prevent MitM on the wire                      | HTTPS only                      |
| Host       | Restrict to trusted domains                   | `api.coingecko.com`             |
| Path       | Validate the specific endpoint                | `/api/v3/coins/bitcoin/history` |
| Parameters | Verify query parameters match expected values | Asset ID extraction             |

## Implementation Patterns

### Pattern 1: HTTPS Enforcement

Always require HTTPS to prevent network-level interception.

```solidity title="contracts/UrlSecurity.sol"
function _validateProtocol(string memory _url) internal pure {
    bytes memory urlBytes = bytes(_url);
    bytes memory httpsPrefix = bytes("https://");

    if (!_startsWith(urlBytes, httpsPrefix)) {
        revert InvalidUrlProtocol();
    }
}

function _startsWith(bytes memory data, bytes memory prefix) internal pure returns (bool) {
    uint256 prefixLen = prefix.length;
    if (data.length < prefixLen) return false;

    for (uint256 i = 0; i < prefixLen; ) {
        if (data[i] != prefix[i]) return false;
        unchecked { ++i; }
    }
    return true;
}
```

### Pattern 2: Host Extraction and Validation

Extract the host from the URL and validate against a whitelist.

```solidity title="contracts/UrlSecurity.sol"
function _extractHost(string memory _url) internal pure returns (string memory) {
    bytes memory urlBytes = bytes(_url);
    bytes memory httpsPrefix = bytes("https://");

    uint256 startIndex = httpsPrefix.length;
    uint256 urlLen = urlBytes.length;
    uint256 endIndex = urlLen;

    // Find the first "/" after the host
    for (uint256 i = startIndex; i < urlLen; ) {
        if (urlBytes[i] == "/") {
            endIndex = i;
            break;
        }
        unchecked { ++i; }
    }

    return string(_slice(urlBytes, startIndex, endIndex));
}

function _validateHost(string memory _url) internal pure {
    string memory host = _extractHost(_url);
    string memory lowerHost = _toLowerCase(host);

    bool validHost = _stringsEqual(lowerHost, "api.coingecko.com") ||
                     _stringsEqual(lowerHost, "api.trusted-source.com");

    if (!validHost) {
        revert InvalidUrlHost(_url, host);
    }
}
```

Case-insensitive comparison prevents bypasses using mixed-case hostnames.

```solidity title="contracts/UrlSecurity.sol"
function _toLowerCase(string memory str) internal pure returns (string memory) {
    bytes memory strBytes = bytes(str);
    uint256 len = strBytes.length;
    bytes memory result = new bytes(len);

    for (uint256 i = 0; i < len; ) {
        bytes1 char = strBytes[i];
        // Convert A-Z (65-90) to a-z (97-122)
        if (char >= 0x41 && char <= 0x5A) {
            result[i] = bytes1(uint8(char) + 32);
        } else {
            result[i] = char;
        }
        unchecked { ++i; }
    }
    return string(result);
}
```

### Pattern 3: Path Validation with StartsWith

Validate that the path begins with the expected endpoint.
Using `startsWith` prevents prefix injection attacks where an attacker creates a path like `/malicious/api/v1/data` that contains your expected path as a substring.

```solidity title="contracts/UrlSecurity.sol"
function _extractPath(string memory _url) internal pure returns (string memory) {
    bytes memory urlBytes = bytes(_url);
    bytes memory httpsPrefix = bytes("https://");

    uint256 startIndex = httpsPrefix.length;
    uint256 urlLen = urlBytes.length;

    // Find the first "/" after the host (start of path)
    for (uint256 i = startIndex; i < urlLen; ) {
        if (urlBytes[i] == "/") {
            return string(_slice(urlBytes, i, urlLen));
        }
        unchecked { ++i; }
    }

    return "";
}

function _validatePath(string memory _url, string memory expectedPathPrefix) internal pure {
    string memory path = _extractPath(_url);

    if (!_startsWith(bytes(path), bytes(expectedPathPrefix))) {
        revert InvalidUrlPath(_url, path);
    }
}
```

### Pattern 4: Parameter Extraction

For APIs like CoinGecko where the asset identifier is embedded in the URL path, extract and validate it.

```solidity title="contracts/UrlSecurity.sol"
/**
 * @notice Extracts the asset ID from a URL like "/coins/{id}/history..."
 * @param _url The full URL string
 * @return The extracted asset ID
 */
function _extractAssetIdFromUrl(string memory _url) internal pure returns (string memory) {
    bytes memory urlBytes = bytes(_url);
    bytes memory prefix = bytes("/coins/");
    bytes memory suffix = bytes("/history");

    uint256 startIndex = _indexOf(urlBytes, prefix);
    if (startIndex == type(uint256).max) {
        return ""; // Prefix not found
    }
    startIndex += prefix.length;

    uint256 endIndex = _indexOfFrom(urlBytes, suffix, startIndex);
    if (endIndex == type(uint256).max) {
        endIndex = urlBytes.length;
    }

    return string(_slice(urlBytes, startIndex, endIndex));
}

function _indexOf(bytes memory data, bytes memory marker) internal pure returns (uint256) {
    uint256 dataLen = data.length;
    uint256 markerLen = marker.length;

    if (markerLen == 0 || dataLen < markerLen) return type(uint256).max;

    for (uint256 i = 0; i <= dataLen - markerLen; i++) {
        bool found = true;
        for (uint256 j = 0; j < markerLen; j++) {
            if (data[i + j] != marker[j]) {
                found = false;
                break;
            }
        }
        if (found) return i;
    }
    return type(uint256).max;
}

function _indexOfFrom(bytes memory data, bytes memory marker, uint256 from) internal pure returns (uint256) {
    uint256 dataLen = data.length;
    uint256 markerLen = marker.length;

    if (markerLen == 0 || dataLen < markerLen) return type(uint256).max;

    for (uint256 i = from; i <= dataLen - markerLen; i++) {
        bool found = true;
        for (uint256 j = 0; j < markerLen; j++) {
            if (data[i + j] != marker[j]) {
                found = false;
                break;
            }
        }
        if (found) return i;
    }
    return type(uint256).max;
}
```

Then validate the extracted ID matches your expected asset:

```solidity title="contracts/UrlSecurity.sol"
function verifyPrice(IWeb2Json.Proof calldata _proof) external {
    // Extract and validate the asset ID from the URL
    string memory extractedId = _extractAssetIdFromUrl(_proof.data.requestBody.url);
    string memory expectedId = assetIdMapping[expectedSymbol];

    if (keccak256(bytes(extractedId)) != keccak256(bytes(expectedId))) {
        revert InvalidAssetIdInUrl(_proof.data.requestBody.url, extractedId, expectedId);
    }

    // Continue with FDC verification...
    require(
        ContractRegistry.getFdcVerification().verifyWeb2Json(_proof),
        "Invalid proof"
    );
}
```

## Complete Example

Here is a complete URL validation function combining all security layers:

```solidity title="contracts/SecureFdcConsumer.sol"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import { ContractRegistry } from "@flarenetwork/flare-periphery-contracts/coston2/ContractRegistry.sol";
import { IWeb2Json } from "@flarenetwork/flare-periphery-contracts/coston2/IWeb2Json.sol";

contract SecureFdcConsumer {
    // Allowed hosts for data sources
    string[] public allowedHosts;

    // Expected API path prefix
    string public expectedPathPrefix;

    error InvalidUrlProtocol();
    error InvalidUrlHost(string url, string host);
    error InvalidUrlPath(string url, string path);
    error SliceOutOfBounds();

    constructor(string[] memory _allowedHosts, string memory _expectedPath) {
        allowedHosts = _allowedHosts;
        expectedPathPrefix = _expectedPath;
    }

    function _validateUrl(string memory _url) internal view {
        bytes memory urlBytes = bytes(_url);

        // 1. Enforce HTTPS
        if (!_startsWith(urlBytes, bytes("https://"))) {
            revert InvalidUrlProtocol();
        }

        // 2. Validate host
        string memory host = _extractHost(_url);
        string memory lowerHost = _toLowerCase(host);

        bool validHost = false;
        for (uint256 i = 0; i < allowedHosts.length; i++) {
            if (_stringsEqual(lowerHost, allowedHosts[i])) {
                validHost = true;
                break;
            }
        }
        if (!validHost) {
            revert InvalidUrlHost(_url, host);
        }

        // 3. Validate path
        string memory path = _extractPath(_url);
        if (!_startsWith(bytes(path), bytes(expectedPathPrefix))) {
            revert InvalidUrlPath(_url, path);
        }
    }

    function consumeData(IWeb2Json.Proof calldata _proof) external {
        // Validate URL before accepting proof
        _validateUrl(_proof.data.requestBody.url);

        // Verify FDC proof
        require(
            ContractRegistry.getFdcVerification().verifyWeb2Json(_proof),
            "Invalid proof"
        );

        // Process the verified data...
    }

    // Helper functions (see implementations above)
    function _startsWith(bytes memory data, bytes memory prefix) internal pure returns (bool) { /* ... */ }
    function _extractHost(string memory _url) internal pure returns (string memory) { /* ... */ }
    function _extractPath(string memory _url) internal pure returns (string memory) { /* ... */ }
    function _toLowerCase(string memory str) internal pure returns (string memory) { /* ... */ }
    function _stringsEqual(string memory a, string memory b) internal pure returns (bool) {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }
    function _slice(bytes memory data, uint256 start, uint256 end) internal pure returns (bytes memory) { /* ... */ }
}
```

## Common Vulnerabilities

### Missing HTTPS Check

Without HTTPS enforcement, an attacker could intercept HTTP requests and modify responses.

```solidity
// ❌ VULNERABLE: Accepts HTTP URLs
function validateUrl(string memory url) internal pure {
    // Only checks host, not protocol
    require(_isAllowedHost(url), "Invalid host");
}

// ✅ SECURE: Requires HTTPS
function validateUrl(string memory url) internal pure {
    require(_startsWith(bytes(url), bytes("https://")), "HTTPS required");
    require(_isAllowedHost(url), "Invalid host");
}
```

### Case-Sensitive Host Comparison

DNS is case-insensitive, so `API.COINGECKO.COM` resolves to the same server as `api.coingecko.com`.

```solidity
// ❌ VULNERABLE: Case-sensitive comparison
function isValidHost(string memory host) internal pure returns (bool) {
    return keccak256(bytes(host)) == keccak256(bytes("api.coingecko.com"));
}

// ✅ SECURE: Case-insensitive comparison
function isValidHost(string memory host) internal pure returns (bool) {
    return keccak256(bytes(_toLowerCase(host))) == keccak256(bytes("api.coingecko.com"));
}
```

### Contains Instead of StartsWith

Using `contains` for path validation allows prefix injection attacks.

```solidity
// ❌ VULNERABLE: Contains check allows prefix injection
// Attacker could use: /malicious/api/v1/price -> contains "/api/v1/price" = true
function isValidPath(string memory path) internal pure returns (bool) {
    return _contains(bytes(path), bytes("/api/v1/price"));
}

// ✅ SECURE: StartsWith prevents prefix injection
function isValidPath(string memory path) internal pure returns (bool) {
    return _startsWith(bytes(path), bytes("/api/v1/price"));
}
```

## Gas Considerations

URL parsing in Solidity is gas-intensive due to string operations.
Consider these optimizations:

1. **Cache host comparisons**: Pre-compute keccak256 hashes of allowed hosts
2. **Limit URL length**: Reject URLs exceeding a maximum length before parsing
3. **Use assembly**: For production contracts, consider assembly-optimized string operations

```solidity title="contracts/GasOptimized.sol"
// Pre-computed host hashes
bytes32 constant COINGECKO_HOST_HASH = keccak256(bytes("api.coingecko.com"));
bytes32 constant BACKUP_HOST_HASH = keccak256(bytes("backup.coingecko.com"));

function _isValidHost(string memory host) internal pure returns (bool) {
    bytes32 hostHash = keccak256(bytes(_toLowerCase(host)));
    return hostHash == COINGECKO_HOST_HASH || hostHash == BACKUP_HOST_HASH;
}
```

## Reference Implementations

For production-ready examples, see:

- [PriceVerifierCustomFeed](https://github.com/flare-foundation/flare-hardhat-starter/blob/main/contracts/customFeeds/PriceVerifierCustomFeed.sol) - Asset ID extraction from CoinGecko URLs

<CodeBlock language="solidity" title="PriceVerifierCustomFeed.sol">
  {PriceVerifierCustomFeed}
</CodeBlock>

## Summary

Secure URL parsing for FDC requires:

1. **HTTPS enforcement** - Reject HTTP URLs
2. **Host whitelisting** - Only accept data from trusted domains
3. **Case-insensitive comparison** - Prevent bypass via mixed-case hosts
4. **Path validation with startsWith** - Prevent prefix injection attacks
5. **Parameter extraction** - Validate embedded identifiers match expected values

Always validate URLs before calling `verifyWeb2Json()`.
A valid FDC proof only guarantees the data came from the URL in the proof—it does not guarantee the URL is trustworthy.
