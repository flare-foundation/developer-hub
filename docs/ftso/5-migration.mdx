---
title: Migrating from v1
slug: migration
description: Migration guide for dApps moving from FTSOv1 to FTSOv2.
keywords:
  [solidity, ftso, flare-time-series-oracle, flare-network, smart-contracts]
---

import CodeBlock from "@theme/CodeBlock";
import FtsoV2MigrationExample from "!!raw-loader!/examples/developer-hub-solidity/FtsoV2MigrationExample.sol";

This guide is for applications moving from FTSOv1 to FTSOv2. Briefly, FTSOv2 comprises of:

- **[Block-Latency Feeds](/ftso/feeds)**: These feeds are updated with each new block, approximately every 1.8 seconds. They can be accessed through `FtsoV2Interface` and are available directly on-chain.
- **[Anchor Feeds](/ftso/scaling/anchor-feeds)**: These feeds are provided through [Scaling](/ftso/scaling/overview) with a latency of 90 seconds. Feeds can be verified using `FtsoV2Interface` but are not immediately available on-chain.

A key difference between the two is the introduction of a payment mechanism for data access. This system helps prevent unnecessary data requests and ensures sustainable funding. For more details, refer to the `FeeCalculator` contract, which calculates fees for data access using the `calculateFeeByIds` and `calculateFeeByIndices` methods.

Additionally, a new Long Term Support (LTS) system has been launched to ensure continued access to essential data and metadata within the Flare ecosystem. A series of LTS contracts have been introduced, each aligned with a specific product in the Flare ecosystem. It is strongly recommended to use these LTS contracts for data access instead of querying individual contracts or interfaces, as they are designed for long-term stability, even as underlying protocols evolve or migrate.

## Deprecated contracts (v1)

### PriceSubmitter

The `PriceSubmitter` contract (`IPriceSubmitter`) is being deprecated as part of the transition to the new version of the FTSO system.

If you were using `PriceSubmitter` for the following purposes, here are the recommended alternatives:

- **Accessing other important contracts**: Use the `IFlareContractRegistry` instead. Refer to the [Flare Contract Registry](#iflarecontractregistry) for details.
- **Voting-related functionalities**: These are now integrated into the new FTSO system.

- **Random number generation** (`getCurrentRandom` or `getRandom`, applicable to Flare only): Switch to the new [`RandomNumberV2Interface`](#randomnumberv2interface). The new protocol updates random numbers every 90 seconds (aligned with the voting epoch duration, as returned by `votingEpochDurationSeconds`). This setting is immutable but could change if the protocol configuration is updated. In contrast, the old protocol updated random numbers every 180 seconds.

#### Required Changes:

- **Use `RandomNumberV2`** instead of `PriceSubmitter` (ensure you update to the new contract address and interface).
- **Method updates**:
  - `getCurrentRandom` → `getRandomNumber`
  - `getRandom(epochId)` → `getRandomNumberHistorical(epochId)`

### FTSO

The legacy `FTSO` contract is being deprecated and replaced. A minimal proxy will be deployed at the same address to provide basic backward compatibility. The replacement will be [`FtsoProxy`](#ftsoproxy), which will respond to a limited subset of calls that the old `FTSO` contract handled. Although the addresses will change, the `FTSORegistry` will be updated to point to the new contract addresses.

#### Recommended Changes:

- **Random number retrieval**: Switch to the new [`RandomNumberV2Interface`](#randomnumberv2interface). The proxy contract will still return current and historical random numbers, but they will be uniform across all `FTSO` contracts, and randomness will be sourced from the new provider.

- **Fetching the current price**: For methods like `getCurrentPrice`, `getCurrentPriceDetails`, or `getCurrentPriceWithDecimals`, switch to the [`FTSOv2Interface`](#ftsov2interface) interface. While the proxy interface will continue to function temporarily, it will not receive future updates.

- **Fetching historical prices**: For methods such as `getEpochPrice`, or retrieving prices for specific voters or trusted data providers, the proxy contract **WILL REVERT**. It is essential to migrate to the new `FTSOv2` interface for these functionalities.

### FTSORegistry

The `FTSORegistry` (`IFTSORegistry`) is being deprecated. While you can continue to use it temporarily with its backward-compatible methods, it is strongly recommended to transition to the new interfaces as soon as possible, as `FTSORegistry` will no longer be maintained in the future.

#### Recommended Changes:

- **Getting FTSOs**: The methods `getFtso`, `getFtsoBySymbol`, `getFtsoIndex`, `getFtsoSymbol`, and `getSupportedIndices/Symbols/Ftsos` are now deprecated. They will still return the proxy implementation of FTSO, but these proxies will not be maintained moving forward. It is recommended to update your code to use the [FTSOv2](#ftsov2interface) interface for price retrieval. Additional details like decimals and timestamps for individual FTSOs are now considered deprecated and can be obtained by querying prices directly through `FTSOv2`.

- **Reading prices** using methods such as `getCurrentPrice(_ftso_index/_symbol)` or their array and decimal implementations is also deprecated. Although these methods will still return correct values, they will not be updated in the future. Use the [FTSOv2](#ftsov2interface) interface instead to ensure future compatibility.

- **Getting supported FTSOs**: This function will return correct results for legacy price pairs but will not be updated for new pairs introduced in the FTSOv2 system. To retrieve information about available pairs in the new system, you should transition to the [FTSOv2](#ftsov2interface) interface.

- **Read prices directly from `FtsoV2Interface`**: This will give you up-to-date prices and more detailed information. Additionally, the `FtsoV2Interface` is part of the Long Term Support (LTS) system, ensuring it will be maintained for an extended period.

- **New system indexing and ID scheme**:
  - The indexing and ID scheme has changed. Old indices are now invalid, so do not use the previous `getFeedByIndex` method with the old indices.
  - IDs in the new system are 21-byte values, formatted as `"${OLD_FEED_NAME}/USD"` and zero-padded.
  - Use the `getFeedById` method in the new interface to retrieve old prices with this format: `getFeedById(bytes21(bytes.concat(bytes1(1), bytes(string.concat(OLD_FEED_NAME, "/USD")))))`.

### FTSORewardManager

The reward system is undergoing significant changes. While an implementation of the old `FTSORewardManager` contract is provided, it will only support the most basic claim types and require pre-provided reward proofs.

#### Recommended Changes:

- **Claiming rewards**: Switch to the new [`RewardsV2Interface`](#rewardsv2interface). The proxy contract will still allow you to claim rewards from the FTSO system, but it will not support claiming fees for data providers.

- **Claiming rewards when delegating by amount**: This feature is no longer supported in the new system.

## LTS interfaces (v2)

The primary goal of the Long Term Support (LTS) interfaces is to offer a stable and reliable way to access essential data and metadata within the Flare ecosystem. These interfaces are designed for long-term maintenance, ensuring continuity even as underlying contracts evolve or protocols migrate to new versions. Each LTS interface is aligned with a specific product within the Flare ecosystem, providing consistency and ease of use over time.

### ProtocolsV2Interface

Interface for managing protocol related metadata.

<details>
<summary>`ProtocolsV2Interface`</summary>

```solidity title="ProtocolsV2Interface.sol"
// SPDX-License-Identifier: MIT
pragma solidity >=0.7.6 <0.9;

/**
 * Protocols V2 long term support interface.
 */
interface ProtocolsV2Interface {

    /**
     * Timestamp when the first reward epoch started, in seconds since UNIX epoch.
     */
    function firstRewardEpochStartTs() external view returns (uint64);

    /**
     * Duration of reward epoch, in seconds.
     */
    function rewardEpochDurationSeconds() external view returns (uint64);

    /**
     * Timestamp when the first voting epoch started, in seconds since UNIX epoch.
     */
    function firstVotingRoundStartTs() external view returns (uint64);

    /**
     * Duration of voting epoch, in seconds.
     */
    function votingEpochDurationSeconds() external view returns (uint64);

    /**
     * Returns the vote power block for given reward epoch id.
     */
    function getVotePowerBlock(uint256 _rewardEpochId)
        external view
        returns(uint64 _votePowerBlock);

    /**
     * Returns the start voting round id for given reward epoch id.
     */
    function getStartVotingRoundId(uint256 _rewardEpochId)
        external view
        returns(uint32);

    /**
     * Returns the current reward epoch id.
     */
    function getCurrentRewardEpochId() external view returns(uint24);

    /**
     * Returns the current voting epoch id.
     */
    function getCurrentVotingEpochId() external view returns(uint32);

}
```

</details>

### RandomNumberV2Interface

This interface allows access to random numbers and is available through the `FlareContractRegistry` under the name `RandomNumberV2`. In addition to providing random numbers, the new methods also return a `_isSecureRandom` flag. This flag indicates whether all data providers have successfully revealed their submissions for the round, ensuring the integrity of the random number.

<details>
<summary>`RandomNumberV2Interface`</summary>

```solidity title="RandomNumberV2Interface.sol"
// SPDX-License-Identifier: MIT
pragma solidity >=0.7.6 <0.9;

/**
 * Random number V2 long term support interface.
 */
interface RandomNumberV2Interface {
    /**
     * Returns the current random number, its timestamp and the flag indicating if it is secure.
     * @return _randomNumber The current random number.
     * @return _isSecureRandom The flag indicating if the random number is secure.
     * @return _randomTimestamp The timestamp of the random number.
     */
    function getRandomNumber()
        external view
        returns (
            uint256 _randomNumber,
            bool _isSecureRandom,
            uint256 _randomTimestamp
        );

    /**
     * Returns the historical random number for a given _votingRoundId,
     * its timestamp and the flag indicating if it is secure.
     * If no finalization in the _votingRoundId, the function reverts.
     * @param _votingRoundId The voting round id.
     * @return _randomNumber The current random number.
     * @return _isSecureRandom The flag indicating if the random number is secure.
     * @return _randomTimestamp The timestamp of the random number.
     */
    function getRandomNumberHistorical(uint256 _votingRoundId)
        external view
        returns (
            uint256 _randomNumber,
            bool _isSecureRandom,
            uint256 _randomTimestamp
        );
}
```

</details>

### FtsoV2Interface

The `FtsoV2Interface` provides access to both block-latency and anchor feed data. It is accessible through the `FlareContractRegistry` under the name `Ftsov2`.

Migrating from V1 to V2 is simple. You can now retrieve prices, updated with block-level latency, by using the `getFeedById` or `getFeedByIndex` methods. Price acquisition is now **payable**, meaning a fee may be required to access the data. While the current fee is set to `0`, it is advisable to use the `FeeCalculator` contract to calculate the fee and be prepared for potential future changes.

<details>
<summary>`FtsoV2Interface`</summary>

```solidity title="FtsoV2Interface.sol"
// SPDX-License-Identifier: MIT
pragma solidity >=0.7.6 <0.9;

/**
 * FtsoV2 long term support interface.
 */
interface FtsoV2Interface {

    /// Feed data structure
    struct FeedData {
        uint32 votingRoundId;
        bytes21 id;
        int32 value;
        uint16 turnoutBIPS;
        int8 decimals;
    }

    /// Feed data with proof structure
    struct FeedDataWithProof {
        bytes32[] proof;
        FeedData body;
    }

    /**
     * Returns stored data of a feed.
     * A fee (calculated by the FeeCalculator contract) may need to be paid.
     * @param _index The index of the feed, corresponding to feed id in
     * the FastUpdatesConfiguration contract.
     * @return _value The value for the requested feed.
     * @return _decimals The decimal places for the requested feed.
     * @return _timestamp The timestamp of the last update.
     */
    function getFeedByIndex(uint256 _index)
        external payable
        returns (
            uint256 _value,
            int8 _decimals,
            uint64 _timestamp
        );

    /**
     * Returns stored data of a feed.
     * A fee (calculated by the FeeCalculator contract) may need to be paid.
     * @param _feedId The id of the feed.
     * @return _value The value for the requested feed.
     * @return _decimals The decimal places for the requested feed.
     * @return _timestamp The timestamp of the last update.
     */
    function getFeedById(bytes21 _feedId)
        external payable
        returns (
            uint256 _value,
            int8 _decimals,
            uint64 _timestamp
        );

    /**
     * Returns stored data of each feed.
     * A fee (calculated by the FeeCalculator contract) may need to be paid.
     * @param _indices Indices of the feeds, corresponding to feed ids in
     * the FastUpdatesConfiguration contract.
     * @return _values The list of values for the requested feeds.
     * @return _decimals The list of decimal places for the requested feeds.
     * @return _timestamp The timestamp of the last update.
     */
    function getFeedsByIndex(uint256[] calldata _indices)
        external payable
        returns (
            uint256[] memory _values,
            int8[] memory _decimals,
            uint64 _timestamp
        );

    /**
     * Returns stored data of each feed.
     * A fee (calculated by the FeeCalculator contract) may need to be paid.
     * @param _feedIds The list of feed ids.
     * @return _values The list of values for the requested feeds.
     * @return _decimals The list of decimal places for the requested feeds.
     * @return _timestamp The timestamp of the last update.
     */
    function getFeedsById(bytes21[] calldata _feedIds)
        external payable
        returns (
            uint256[] memory _values,
            int8[] memory _decimals,
            uint64 _timestamp
        );

    /**
     * Returns value in wei and timestamp of a feed.
     * A fee (calculated by the FeeCalculator contract) may need to be paid.
     * @param _index The index of the feed, corresponding to feed id in
     * the FastUpdatesConfiguration contract.
     * @return _value The value for the requested feed in wei (i.e. with 18 decimal places).
     * @return _timestamp The timestamp of the last update.
     */
    function getFeedByIndexInWei(
        uint256 _index
    )
        external payable
        returns (
            uint256 _value,
            uint64 _timestamp
        );

    /**
     * Returns value in wei and timestamp of a feed.
     * A fee (calculated by the FeeCalculator contract) may need to be paid.
     * @param _feedId The id of the feed.
     * @return _value The value for the requested feed in wei (i.e. with 18 decimal places).
     * @return _timestamp The timestamp of the last update.
     */
    function getFeedByIdInWei(bytes21 _feedId)
        external payable
        returns (
            uint256 _value,
            uint64 _timestamp
        );

    /** Returns value in wei of each feed and a timestamp.
     * For some feeds, a fee (calculated by the FeeCalculator contract) may need to be paid.
     * @param _indices Indices of the feeds, corresponding to feed ids in
     * the FastUpdatesConfiguration contract.
     * @return _values The list of values for the requested feeds in wei (i.e. with 18 decimal places).
     * @return _timestamp The timestamp of the last update.
     */
    function getFeedsByIndexInWei(uint256[] calldata _indices)
        external payable
        returns (
            uint256[] memory _values,
            uint64 _timestamp
        );

    /** Returns value of each feed and a timestamp.
     * For some feeds, a fee (calculated by the FeeCalculator contract) may need to be paid.
     * @param _feedIds Ids of the feeds.
     * @return _values The list of values for the requested feeds in wei (i.e. with 18 decimal places).
     * @return _timestamp The timestamp of the last update.
     */
    function getFeedsByIdInWei(bytes21[] calldata _feedIds)
        external payable
        returns (
            uint256[] memory _values,
            uint64 _timestamp
        );

    /**
     * Returns the index of a feed.
     * @param _feedId The feed id.
     * @return _index The index of the feed.
     */
    function getFeedIndex(bytes21 _feedId) external view returns (uint256 _index);

    /**
     * Returns the feed id at a given index. Removed (unused) feed index will return bytes21(0).
     * @param _index The index.
     * @return _feedId The feed id.
     */
    function getFeedId(uint256 _index) external view returns (bytes21 _feedId);

    /**
     * Checks if the feed data is valid (i.e. is part of the confirmed Merkle tree).
     * @param _feedData Structure containing data about the feed (FeedData structure) and Merkle proof.
     * @return true if the feed data is valid.
     */
    function verifyFeedData(FeedDataWithProof calldata _feedData) external view returns (bool);
}
```

</details>

### RewardsV2Interface

Interface for claiming rewards from Flare Systems Protocol (FSP) and all sub-protocols.

<details>
<summary>`RewardsV2Interface`</summary>

```solidity title="RewardsV2Interface.sol"
// SPDX-License-Identifier: MIT
pragma solidity >=0.7.6 <0.9;

/**
 * Rewards V2 long term support interface.
 */
interface RewardsV2Interface {

    /// Claim type enum.
    enum ClaimType { DIRECT, FEE, WNAT, MIRROR, CCHAIN }

   /// Struct used for claiming rewards with Merkle proof.
    struct RewardClaimWithProof {
        bytes32[] merkleProof;
        RewardClaim body;
    }

    /// Struct used in Merkle tree for storing reward claims.
    struct RewardClaim {
        uint24 rewardEpochId;
        bytes20 beneficiary; // c-chain address or node id (bytes20) in case of type MIRROR
        uint120 amount; // in wei
        ClaimType claimType;
    }

    /// Struct used for returning state of rewards.
    struct RewardState {
        uint24 rewardEpochId;
        bytes20 beneficiary; // c-chain address or node id (bytes20) in case of type MIRROR
        uint120 amount; // in wei
        ClaimType claimType;
        bool initialised;
    }

    /**
     * Claim rewards for `_rewardOwner` and transfer them to `_recipient`.
     * It can be called by reward owner or its authorized executor.
     * @param _rewardOwner Address of the reward owner.
     * @param _recipient Address of the reward recipient.
     * @param _rewardEpochId Id of the reward epoch up to which the rewards are claimed.
     * @param _wrap Indicates if the reward should be wrapped (deposited) to the WNAT contract.
     * @param _proofs Array of reward claims with merkle proofs.
     * @return _rewardAmountWei Amount of rewarded native tokens (wei).
     */
    function claim(
        address _rewardOwner,
        address payable _recipient,
        uint24 _rewardEpochId,
        bool _wrap,
        RewardClaimWithProof[] calldata _proofs
    )
        external
        returns (uint256 _rewardAmountWei);

    /**
     * Indicates if the contract is active - claims are enabled.
     */
    function active() external view returns (bool);

    /**
     * Returns the start and the end of the reward epoch range for which the reward is claimable.
     * @return _startEpochId The oldest epoch id that allows reward claiming.
     * @return _endEpochId The newest epoch id that allows reward claiming.
     */
    function getRewardEpochIdsWithClaimableRewards()
        external view
        returns (
            uint24 _startEpochId,
            uint24 _endEpochId
        );

    /**
     * Returns the next claimable reward epoch for a reward owner.
     * @param _rewardOwner Address of the reward owner to query.
     */
    function getNextClaimableRewardEpochId(address _rewardOwner) external view returns (uint256);

    /**
     * Returns the state of rewards for a given address for all unclaimed reward epochs with claimable rewards.
     * @param _rewardOwner Address of the reward owner.
     * @return _rewardStates Array of reward states.
     */
    function getStateOfRewards(
        address _rewardOwner
    )
        external view
        returns (
            RewardState[][] memory _rewardStates
        );

}
```

</details>

## Migration proxies

For the time being, a set of proxy contracts is provided to allow access to the old data and reward systems.

:::warning[Do not use for new developments]

These proxies offer a temporary solution to ensure that previously deployed contracts can continue functioning until they are fully updated.

:::

### FtsoProxy

The `FtsoProxy` contract is designed to maintain backward compatibility with the old FTSO contract. While it will be deployed at different addresses from the original FTSO contract, the `FTSORegistry` will be updated to point to these new addresses.

<details>
<summary>Methods in `FtsoProxy`</summary>

```solidity title="FtsoProxy.sol"
   /**
     * Always return true, as the proxy is always active.
     */
    function active() external pure returns (bool) {
        return true;
    }

    /**
     * Will return the current epoch id correctly as defined by FSP
     */
    function getCurrentEpochId() external view returns (uint256) {
    }

    /**
     * Will return the epoch id correctly as defined by FSP.
     * Beware, the function will produce different results than the old FTSO contract.
     */
    function getEpochId(uint256 _timestamp) external view returns (uint256) {
    }

    /**
     * Will return the current random correctly
     */
    function getRandom(uint256 _votingRoundId) external view returns (uint256 _randomNumber) {
    }

    /**
     * @dev Deprecated - reverts
     */
    function getEpochPrice(uint256) external pure returns (uint256) {
        revert("not supported");
    }

    /**
     * Will return current price epoch data as defined by FSP
     */
    function getPriceEpochData() external view
        returns (
            uint256 _epochId,
            uint256 _epochSubmitEndTime,
            uint256 _epochRevealEndTime,
            uint256 _votePowerBlock,
            bool _fallbackMode
        )
    {
    }

    /**
     * Will return the price epoch configuration as defined by FSP
     */
    function getPriceEpochConfiguration() external view
        returns (
            uint256 _firstEpochStartTs,
            uint256 _submitPeriodSeconds,
            uint256 _revealPeriodSeconds
        )
    {
    }

    /**
     * @dev Deprecated - reverts
     */
    function getEpochPriceForVoter(uint256, address) external pure returns (uint256) {
        revert("not supported");
    }

    /**
     * Will return the current price correctly
     */
    function getCurrentPrice() external view returns (uint256, uint256) {
    }

    /**
     * Will return the current price with decimals correctly
     */
    function getCurrentPriceWithDecimals()
        external view
        returns (
            uint256 _value,
            uint256 _timestamp,
            uint256 _decimals
        )
    {
    }


    /**
     * Will return the current price with details correctly
     */
    function getCurrentPriceDetails()
        external view
        returns (
            uint256,
            uint256,
            PriceFinalizationType,
            uint256,
            PriceFinalizationType
        )
    {
    }

    /**
     * @dev Deprecated - reverts
     */
    function getCurrentPriceFromTrustedProviders() external pure returns (uint256, uint256) {
        revert("not supported");
    }

    /**
     * @dev Deprecated - reverts
     */
    function getCurrentPriceWithDecimalsFromTrustedProviders() external pure returns (uint256, uint256, uint256) {
        revert("not supported");
    }

    /**
     * Will return the current random correctly
     */
    function getCurrentRandom() external view returns (uint256 _currentRandom) {
    }

```

</details>

### FtsoRewardManagerProxy

The `FtsoRewardManagerProxy` contract is designed to maintain backward compatibility with the old `FTSORewardManager` contract. It will be deployed at a different address than the original contract.

This proxy only supports the most basic reward claim types and requires that reward proofs be provided in advance.

<details>
<summary>Methods in `FtsoRewardManagerProxy`</summary>

```solidity title="FtsoRewardManagerProxy.sol"
    /**
     * @dev Claims rewards correctly for delegation fees, assuming the proofs were already provided.
     */
    function claimReward(
        address payable _recipient,
        uint256[] calldata _rewardEpochs
    )
        external
        returns (uint256 _rewardAmount)
    {
    }

    /**
     * @dev Claims rewards correctly for delegation fees, assuming the proofs were already provided.
     */
    function claim(
        address _rewardOwner,
        address payable _recipient,
        uint256 _rewardEpoch,
        bool _wrap
    )
        external
        returns (uint256 _rewardAmount)
    {
    }


    /**
     * @dev Returns the current fee percentage for the data provider.
     */
    function getDataProviderCurrentFeePercentage(address _dataProvider)
        external view
        returns (uint256 _feePercentageBIPS)
    {
    }

    /**
     * @dev Returns the fee percentage for the data provider for the given reward epoch.
     */
    function getDataProviderFeePercentage(
        address _dataProvider,
        uint256 _rewardEpoch
    )
        external view
        returns (uint256 _feePercentageBIPS)
    {
    }

    /**
     * @dev Returns the fee percentage changes for the data provider.
     */
    function getDataProviderScheduledFeePercentageChanges(address _dataProvider) external view
        returns (
            uint256[] memory _feePercentageBIPS,
            uint256[] memory _validFromEpoch,
            bool[] memory _fixed
        )
    {
    }

    /**
     * @dev Returns the epoch reward correctly
     */
    function getEpochReward(uint256 _rewardEpoch) external view
        returns (uint256 _totalReward, uint256 _claimedReward)
    {
    }

    /**
     * @dev Returns the reward state correctly
     */
    function getStateOfRewards(
        address _beneficiary,
        uint256 _rewardEpoch
    )
        external view
        returns (
            address[] memory _dataProviders,
            uint256[] memory _rewardAmounts,
            bool[] memory _claimed,
            bool _claimable
        )
    {
    }

    /**
     * @dev Returns the epochs with claimable rewards correctly
     */
    function getEpochsWithClaimableRewards() external view
        returns (uint256 _startEpochId, uint256 _endEpochId)
    {
    }

    /**
     * @dev Returns the next claimable reward epoch correctly
     */
    function nextClaimableRewardEpoch(address _rewardOwner) external view returns (uint256) {
    }

    /**
     * @dev Returns the epochs with unclaimed rewards correctly
     */
    function getEpochsWithUnclaimedRewards(address _beneficiary) external view
        returns (uint256[] memory _epochIds)
    {
    }

    /**
     * @dev Returns the claimed rewardr correctly
     */
    function getClaimedReward(
        uint256 _rewardEpoch,
        address _dataProvider,
        address _claimer
    )
        external view
        returns (
            bool _claimed,
            uint256 _amount
        )
    {
    }

    /**
     * @dev Returns the reward epoch to expire next correctly
     */
    function getRewardEpochToExpireNext() external view returns (uint256) {
    }

    /**
     * @dev Returns the reward epoch vote power block correctly
     */
    function getRewardEpochVotePowerBlock(uint256 _rewardEpoch) external view returns (uint256) {
    }

    /**
     * @inheritdoc IFtsoRewardManager
     */
    function getCurrentRewardEpoch() external view returns (uint256) {
        return rewardManager.getCurrentRewardEpochId();
    }

    /**
     * @inheritdoc IFtsoRewardManager
     */
    function getInitialRewardEpoch() external view returns (uint256 _initialRewardEpoch) {
        return rewardManager.getInitialRewardEpochId();
    }

    /**
     * @inheritdoc IFtsoRewardManager
     * @dev Deprecated
     */
    function claimRewardFromDataProviders(
        address payable,
        uint256[] calldata,
        address[] calldata
    )
        external pure returns (uint256)
    {
        // return 0
    }

    /**
     * @inheritdoc IFtsoRewardManager
     * @dev Deprecated
     */
    function claimFromDataProviders(
        address,
        address payable,
        uint256[] calldata,
        address[] calldata,
        bool
    )
        external pure returns (uint256)
    {
        // return 0
    }

    /**
     * @inheritdoc IFtsoRewardManager
     * @dev Deprecated - reverts
     */
    function autoClaim(address[] calldata, uint256) external pure {
        revert("not supported, use RewardManager");
    }

    /**
     * @inheritdoc IFtsoRewardManager
     * @dev Deprecated - reverts
     */
    function setDataProviderFeePercentage(uint256)
        external pure
        returns (uint256)
    {
        revert("not supported, use WNatDelegationFee");
    }

    /**
     * @dev Deprecated - returns empty array, empty array, false
     */
    function getStateOfRewardsFromDataProviders(
        address,
        uint256,
        address[] calldata
    )
        external pure
        returns (
            uint256[] memory,
            bool[] memory,
            bool
        )
    {
    }

    /**
     * Deprecated - returns 0, 0
     */
    function getDataProviderPerformanceInfo(
        uint256,
        address
    )
        external pure
        returns (
            uint256,
            uint256
        )
    {
    }

```

</details>

## Usable existing interfaces

### FlareContractRegistry

[`FlareContractRegistry`](/network/solidity-reference) provides access to the addresses of all key contracts within the Flare system. It is deployed at a fixed address on all networks, with addresses updated through governance. This registry serves as the recommended entry point for interacting with contracts across the Flare ecosystem.

For a more user-friendly experience, you can use the `ContractLibrary` available in the [flare-periphery-contracts](https://www.npmjs.com/package/@flarenetwork/flare-periphery-contracts?activeTab=readme) library. This library wraps `IFlareContractRegistry` and simplifies interactions with the system.

### FeeCalculator

Prices that are directly available on-chain are now subject to potential fees. While the initial fees are set to `0`, this system is designed to be flexible for future use cases where fees may be introduced.

Fees are calculated by the `FeeCalculator` contract, which determines the cost of accessing data using the `calculateFeeByIds` and `calculateFeeByIndices` methods. It is recommended to use the `FeeCalculator` contract to stay prepared for any future changes to the fee structure.

<details>
<summary>`FeeCalculator` interface</summary>

```solidity title="IFeeCalculator.sol"
// SPDX-License-Identifier: MIT
pragma solidity >=0.7.6 <0.9;


/**
 * FeeCalculator interface.
 */
interface IFeeCalculator {
    /**
     * Calculates a fee that needs to be paid to fetch feeds' data.
     * @param _feedIds List of feed ids.
    */
    function calculateFeeByIds(bytes21[] memory _feedIds) external view returns (uint256 _fee);

    /**
     * Calculates a fee that needs to be paid to fetch feeds' data.
     * @param _indices Indices of the feeds, corresponding to feed ids in
     * the FastUpdatesConfiguration contract.
    */
    function calculateFeeByIndices(uint256[] memory _indices) external view returns (uint256 _fee);
}
```

</details>

## Example migration contract

<CodeBlock language="solidity" title="FtsoV2MigrationExample.sol">
  {FtsoV2MigrationExample}
</CodeBlock>
